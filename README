Вариант 17: Подсчет количества листьев в бинарном дереве
Суть алгоритма:
Рекурсивный обход бинарного дерева для подсчета узлов, не имеющих потомков (листьев).

Определение листа: узел, у которого отсутствуют оба потомка (левый и правый).

Рекурсивный алгоритм:
Базовый случай: Если текущий узел null — вернуть 0

Рекурсивный случай:

Если узел является листом (нет левого и правого потомка) — вернуть 1

Иначе — вернуть сумму листьев в левом и правом поддеревьях

Пример дерева:
text
       1
      / \
     2   3
    / \
   4   5
Листья: узлы 4, 5, 3

Последовательность подсчета:

Узел 1: не лист → countLeaves(2) + countLeaves(3)

Узел 2: не лист → countLeaves(4) + countLeaves(5)

Узел 4: лист → возвращает 1

Узел 5: лист → возвращает 1

Узел 3: лист → возвращает 1

Итог: 1 + 1 + 1 = 3 листа

Шаги алгоритма:
Шаг 1: Проверка базового случая

python
if root is None:
    return 0
Шаг 2: Проверка, является ли узел листом

python
if root.left is None and root.right is None:
    return 1
Шаг 3: Рекурсивный подсчет листьев в поддеревьях

python
return count_leaves(root.left) + count_leaves(root.right)
Временная сложность: O(n)
Объяснение временной сложности:
O(n) возникает из-за того, что каждый узел дерева обрабатывается ровно один раз. Алгоритм должен посетить все узлы, чтобы определить, являются ли они листьями, поскольку нельзя заранее узнать структуру поддеревьев без их проверки.

Ответ на контрольный вопрос:
Объясните, почему рекурсивный алгоритм подсчета листьев имеет линейную сложность

Рекурсивный алгоритм подсчета листьев имеет временную сложность O(n), где n - количество узлов в дереве, потому что:

Полный обход: Алгоритм должен посетить каждый узел дерева ровно один раз, так как невозможно определить, является ли узел листом, не проверив его непосредственные связи.

Константные операции на узел: Для каждого узла выполняется фиксированное количество операций:

Проверка на null

Проверка условий (отсутствие потомков)

Арифметическая операция сложения

Рекуррентное соотношение:

text
T(n) = T(left) + T(right) + O(1)
Сумма размеров всех поддеревьев равна n, поэтому общее время выполнения пропорционально n.

Независимость от структуры: Сложность O(n) сохраняется для любой структуры бинарного дерева - сбалансированного, вырожденного или полного.

Таким образом, алгоритм является оптимальным для данной задачи, так как любое решение должно проверить все n узлов для точного подсчета листьев.



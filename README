Анализ работы алгоритма
1. Задание

Вариант 1. Жадный алгоритм для вершинного покрытия
Задача: реализовать жадный 2-аппроксимационный алгоритм для задачи о вершинном покрытии. Входные данные представляют собой граф, заданный списком ребер. Необходимо найти множество вершин, таких что каждое ребро имеет хотя бы один конец в этом множестве.

Требования:

    Реализовать алгоритм на C++

    Проверить корректность решения

    Вывести размер найденного покрытия и само покрытие

    Оценить коэффициент аппроксимации (должен быть ≤ 2)

Входные данные:
Граф с 10 вершинами (0-9) и следующими ребрами:
(0,1), (1,2), (2,3), (3,4), (4,5), (5,6), (6,7), (7,8), (8,9), (9,0)

2. Анализ работы алгоритма

Алгоритм работает по следующей схеме:

    Инициализация: Создаются пустое множество для вершинного покрытия и копия множества всех ребер графа
    cpp

set<int> cover;
set<pair<int, int>> remainingEdges;

Основной цикл: Пока есть непокрытые ребра:

    Выбирается произвольное ребро (u, v)

cpp

auto it = remainingEdges.begin();
int u = it->first;
int v = it->second;

    Обе вершины добавляются в покрытие

cpp

cover.insert(u);
cover.insert(v);

    Удаляются все ребра, инцидентные любой из добавленных вершин

cpp

if (edgeIt->first == u || edgeIt->first == v || 
    edgeIt->second == u || edgeIt->second == v)

    Завершение: Возвращается построенное вершинное покрытие

Коэффициент аппроксимации: Алгоритм гарантирует 2-аппроксимацию, так как для каждого выбранного ребра мы берем обе вершины, в то время как оптимальное решение должно содержать хотя бы одну из них.

3. Временная сложность

O(E²) в худшем случае

4. Пояснение временной сложности

Временная сложность O(E²) в силу следующих факторов:

    Внешний цикл выполняется O(E) раз (пока есть ребра)

    На каждой итерации выполняется поиск и удаление инцидентных ребер, что в худшем случае требует O(E) операций

    Каждая операция удаления из set имеет сложность O(log E)

    Таким образом, общая сложность составляет O(E × E × log E) = O(E² log E), что упрощается до O(E²)

5. Ответ на контрольный вопрос

1. Определение приближенных алгоритмов
Что такое приближенный алгоритм и какова его основная цель в решении NP-сложных задач?

Приближенный алгоритм — это алгоритм, который находит решение оптимизационной задачи, гарантирующее решение, близкое к оптимальному. Эти алгоритмы разработаны для NP-сложных задач, когда поиск точного оптимального решения вычислительно невозможен за полиномиальное время.

Основная цель приближенных алгоритмов для NP-сложных задач заключается в нахождении решений, которые:

    Вычисляются за полиномиальное время

    Гарантированно находятся в определенной близости от оптимального решения (определяется коэффициентом аппроксимации)

    Позволяют практически решать сложные задачи, для которых точные алгоритмы требуют экспоненциального времени

Таким образом, приближенные алгоритмы представляют собой компромисс между точностью решения и временем вычисления, что делает их незаменимыми инструментами для решения реальных NP-сложных задач.

1. Сортировка выбором (Selection Sort)
Определение: Сортировка выбором — это алгоритм сортировки, который работает путём многократного поиска минимального элемента из неотсортированной части массива и его обмена с первым элементом неотсортированной части.

Описание: На каждом шаге алгоритма находят минимальный элемент среди неотсортированных и меняют его местами с текущим элементом массива.

Пошаговая работа:

Начинаем с первого элемента массива (цикл for с индексом i)

Находим минимальный элемент в неотсортированной части (внутренний цикл for с индексом j и оператором сравнения arr[j] < arr[minIndex])

Меняем местами найденный минимальный элемент с текущим (операция swap с использованием временной переменной temp)

Увеличиваем отсортированную часть на один элемент (инкремент i++)

Повторяем процесс для оставшейся части массива

Сложность: O(n²) во всех случаях
Почему: Алгоритм всегда выполняет два вложенных цикла — внешний проходит по всем элементам, внутренний ищет минимум среди оставшихся, что даёт квадратичную сложность.

Пример:
Исходный массив: [23, 56, 21, 41, 12]
Отсортированный массив: [12, 21, 23, 41, 56]

2. Сортировка пузырьком (Bubble Sort)
Определение: Сортировка пузырьком — это простой алгоритм, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке.

Описание: Сравниваются соседние элементы и при необходимости меняются местами.

Пошаговая работа:

Проходим по массиву несколько раз (внешний цикл for с индексом i)

Сравниваем соседние элементы (оператор if с условием arr[j] > arr[j + 1])

Если левый больше правого — меняем их местами (операция swap с временной переменной temp)

После каждого прохода наибольший элемент всплывает в конец (уменьшение границы n - i - 1)

Повторяем до полной сортировки (флаг swapped с проверкой if (swapped == false))

Сложность:
Худший и средний случай: O(n²)
Лучший случай (уже отсортированный массив): O(n)
Почему: Алгоритм сравнивает все пары соседних элементов. В худшем случае нужно пройти n раз по n элементам (O(n²)), но если массив уже отсортирован — достаточно одного прохода (O(n)).

Пример:
Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]

3. Сортировка вставками (Insertion Sort)
Определение: Сортировка вставками строит отсортированную часть массива, вставляя каждый новый элемент на правильное место.

Описание: Алгоритм вставляет каждый элемент в нужную позицию в отсортированной части.

Пошаговая работа:

Начинаем со второго элемента (цикл for с индексом i, начиная с i = 1)

Запоминаем текущий элемент (переменная key = arr[i])

Сдвигаем элементы, большие текущего, вправо (цикл while с условием j >= 0 && arr[j] > key)

Вставляем элемент на найденную позицию (arr[j + 1] = key)

Повторяем для всех элементов

Сложность:
Худший и средний случай: O(n²)
Лучший случай: O(n)
Почему: Каждый новый элемент сравнивается со всеми элементами отсортированной части. В худшем случае это n сравнений для каждого из n элементов (O(n²)), а если массив отсортирован — только одно сравнение на элемент (O(n)).

Пример:
Исходный массив: [15, 8, 42, 4, 23, 16]
Отсортированный массив: [4, 8, 15, 16, 23, 42]

4. Сортировка слиянием (Merge Sort)
Определение: Алгоритм "разделяй и властвуй", который рекурсивно делит массив пополам и объединяет отсортированные части.

Описание: Делим массив, сортируем части и объединяем.

Пошаговая работа:

Разделяем массив пополам (рекурсивные вызовы mergeSort(left, right))

Рекурсивно сортируем левую и правую половины (вызовы mergeSort для обеих частей)

Объединяем отсортированные половины (функция merge с циклами while для сравнения leftArr[i] <= rightArr[j])

Сложность: O(n log n) во всех случаях
Почему: Массив делится пополам log n раз, а на каждом уровне объединяются n элементов. Это даёт общую сложность O(n log n).

Пример:
Исходный массив: [38, 27, 43, 3, 9, 82, 10]
Отсортированный массив: [3, 9, 10, 27, 38, 43, 82]

5. Сортировка Шелла (Shell Sort)
Определение: Сортировка Шелла — это усовершенствованная версия сортировки вставками, которая сравнивает элементы на определённом расстоянии.

Описание: Сравнение и перестановка элементов на определённом шаге.

Пошаговая работа:

Выбираем шаг (gap = n / 2)

Сортируем элементы с этим шагом методом вставок (цикл for с шагом gap и условием arr[j - gap] > temp)

Уменьшаем шаг (gap = gap / 2)

Завершаем сортировку с шагом 1

Сложность:
В среднем O(n log n), в худшем — O(n²)
Почему: Сортировка вставками выполняется на подмассивах, расстояние между элементами уменьшается с каждым проходом. Это ускоряет упорядочивание по сравнению с обычной вставкой, но сложность зависит от выбора последовательности шагов.

Пример:
Исходный массив: [23, 12, 1, 8, 34, 54, 2, 3]
Отсортированный массив: [1, 2, 3, 8, 12, 23, 34, 54]

6. Быстрая сортировка (Quick Sort)
Определение: Алгоритм "разделяй и властвуй", который выбирает опорный элемент и делит массив на части, меньшие и большие его.

Описание: Делим массив относительно опорного элемента и сортируем рекурсивно.

Пошаговая работа:

Выбираем опорный элемент (pivot = arr[high])

Делим массив на элементы меньше и больше pivot (функция partition с циклами while и условиями arr[i] <= pivot, arr[j] > pivot)

Рекурсивно сортируем обе части (вызовы quickSort для левой и правой частей)

Объединяем результат (на месте)

Сложность:
Средний случай: O(n log n)
Худший случай: O(n²)
Почему: Если опорный элемент делит массив примерно пополам — глубина рекурсии log n, а на каждом уровне обрабатываются n элементов (O(n log n)). Если же pivot выбирается плохо (например, всегда крайний элемент), деление становится неравномерным, и сложность возрастает до O(n²).

Пример:
Исходный массив: [24, 15, 38, 2, 19, 41, 8]
Отсортированный массив: [2, 8, 15, 19, 24, 38, 41]

7. Пирамидальная сортировка (Heap Sort)
Определение: Пирамидальная сортировка использует структуру данных "куча" для упорядочивания элементов.

Описание: Строим max-кучу и извлекаем элементы по одному.

Пошаговая работа:

Строим max-кучу (функция buildMaxHeap с циклом for)

Корень кучи содержит максимальный элемент (arr[0])

Меняем корень с последним элементом (операция swap)

Восстанавливаем кучу (функция heapify с рекурсией и сравнением arr[largest] > arr[i])

Повторяем, пока куча не пуста

Сложность: O(n log n) во всех случаях
Почему: Построение кучи выполняется за O(n), а каждая операция извлечения и восстановления кучи требует O(log n). Для n элементов — O(n log n).

Пример:
Исходный массив: [4, 10, 3, 5, 1]
Отсортированный массив: [1, 3, 4, 5, 10]
